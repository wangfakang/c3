{
  "name": "C3",
  "tagline": "c 函数返回值的陷阱",
  "body": "简单解析c语言的一个坑:\r\n\r\n先看看下面代码的输出结果：\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\n#include <stdio.h>\r\n\r\nint funx()\r\n{\r\n    int a = 9;\r\n    int b = 7;\r\n    int c = 0;\r\n\r\n    c = a + b;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    int c = funx();\r\n\r\n    printf(\"%d\\n\", c);\r\n\r\n}\r\n\r\n```\r\n\r\n结果是16，对就是16.而且这个数字不是随机的。如果你知道了原因就不用再往下看了。\r\n\r\n下面就来分析一下：\r\n其实这个16就是a+b的值，那么问什么么恩？下面就来看看相应的汇编：\r\n\r\n```c\r\n        .file   \"re.c\"\r\n        .text\r\n.globl funx\r\n        .type   funx, @function\r\nfunx:\r\n.LFB0:\r\n        .cfi_startproc\r\n        pushq   %rbp\r\n        .cfi_def_cfa_offset 16\r\n        .cfi_offset 6, -16\r\n        movq    %rsp, %rbp\r\n        .cfi_def_cfa_register 6\r\n        movl    $9, -12(%rbp)    //把立即数9放到寄存器相对偏移量12的位置[即a的地址里面]\r\n        movl    $7, -8(%rbp)     //把立即数7放到寄存器相对偏移量8的位置[即b的地址里面]\r\n        movl    $0, -4(%rbp)     //把立即数0放到寄存器相对偏移量4的位置[即c的地址里面]\r\n        movl    -8(%rbp), %eax   //把b的值取出来放到eax中\r\n        movl    -12(%rbp), %edx  //把a的值取出来放到edx中\r\n        leal    (%rdx,%rax), %eax //把rdx加上rax的值放到eax中\r\n        movl    %eax, -4(%rbp)    //把eax的值给c  最终eax就是a+b等于16\r\n        leave\r\n        .cfi_def_cfa 7, 8\r\n        ret\r\n        .cfi_endproc\r\n.LFE0:\r\n        .size   funx, .-funx\r\n        .section        .rodata\r\n.LC0:\r\n        .string \"%d\\n\"\r\n        .text\r\n.globl main\r\n        .type   main, @function\r\nmain:\r\n.LFB1:\r\n        .cfi_startproc\r\n        pushq   %rbp\r\n        .cfi_def_cfa_offset 16\r\n        .cfi_offset 6, -16\r\n        movq    %rsp, %rbp\r\n        .cfi_def_cfa_register 6\r\n        subq    $16, %rsp\r\n        movl    $0, %eax\r\n        call    funx     //调用funx函数\r\n        movl    %eax, -4(%rbp)  //这个eax就是函数funx的返回值给c\r\n        movl    $.LC0, %eax\r\n        movl    -4(%rbp), %edx\r\n        movl    %edx, %esi\r\n        movq    %rax, %rdi\r\n        movl    $0, %eax\r\n        call    printf\r\n        leave\r\n        .cfi_def_cfa 7, 8\r\n        ret\r\n        .cfi_endproc\r\n.LFE1:\r\n        .size   main, .-main\r\n        .ident  \"GCC: (GNU) 4.4.6 20110731 (Red Hat 4.4.6-3)\"\r\n        .section        .note.GNU-stack,\"\",@progbits\r\n\r\n```\r\n\r\n上面的汇编代码的第13到19行就是该问题的关键。还有就是第42到43行。      \r\n简单的看了上面汇编代码的解析，应该就知道原因了。      \r\n其实在c语言中函数的返回值是放在eax寄存器中的。[当然有的64位的也会把高32位放在edx，\r\n低32位放在eax中]。    \r\n\r\n\r\n虽然上面的c语言代码写的很不规范，一眼就看出来不对，但是有时候一个函数的逻辑比较返回值比较多\r\n而有的时候就会由于逻辑的问题最终一种情况没有return的逻辑。而调用者又使用该返回值来做后面的判\r\n断是很容易出问题的。     \r\n\r\nCommunite  \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/fakangwang)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}